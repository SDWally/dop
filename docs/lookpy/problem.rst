面试理论问题
++++++++++++

基本数据类型
------------

int
-----

float
-------

str
-----

list
—------

dict
--------

set
------



函数
------

1. 编译后的函数定义体保存在函数的哪个属性中？

__code__

2. 闭包中自由变量的绑定在函数的什么属性中？这一属性是什么数据类型？

__closure__ list

3. 叠放装饰器的执行顺序。

最贴近函数的先调用函数，然后返回结果依次向上作为参数传递并调用。

4. 参数传递是采用什么方式？

共享传参。

5.


装饰器
---------

1. Python内置了三个用于装饰方法的函数。

property/classmethod/staticmethod

2. functools模块里的装饰器有哪些？

functools.wraps functools.lru_cache functools.singledispatch

3.

类
------

1. 类的实例的创建过程。

调用__new___方法创建一个实例，调用__init__方法初始化实例。

2. 一个对象什么情况下会被销毁？

Python垃圾回收使用的主要算法是引用计数。每个对象都会统计有多少引用指向自己。当引用计数归零时，对象立即就被销毁。

3. del会删除一个对象吗？

del不会删除一个对象，它删除对象名称，导致对象不可被获取，从而被删除。

4. 一个对象的类型可以变化吗？

可以，为__class__属性指定其他类。

5. Python中用户自定义的类，它的实例默认是可变的还是不可变的？

默认为可变的。




元类
------

设计模式
---------

其他
-------

1. 关于is的考察。

每个变量都有标识/类型和值。对象一旦创建，它的标识绝不会变。可以把标识理解为对象在内存中的地址。

==比较两个对象的值，is比较对象的标识。

2. id（）返回的是什么？

返回对象标识的整数表示。

3. is运算符和==运算符，哪个更快？

is更快，它不能重载。

4. 什么是可散列的数据类型？

在这个对象的生命周期中，它的散列值是不变的。这个对象需要实现__hash__方法，还有__eq__方法。如果两个可散列对象相等，那么它们的散列值一定是一样的。

原子不可变数据类型都是可散列类型，frozenset也是可散列的。对于元组，只有当它包含的所有元素都是可散列的情况下，它才是可散列的。

用户自定义类的对象都是可散列的，散列值就是它们的id（）函数的返回值。如果一个对象实现了__eq__方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些状态
都是不可变的情况下，这个对象才是可散列的。

5. 为什么通常使用None作为接受可变值的参数的默认值？

默认值在定义函数时计算（通常在加载模块时），因此，默认值变成了函数对象的属性。如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。

6. 如何监视一个对象生命结束时的情形？比如在销毁后调用一个函数。

采用weakref.finalize可以注册一个回调函数，在销毁对象时调用。

7. list和dict实例可以作为弱引用的目标（所指对象）吗？int和tuple的实例可以作为弱引用的目标吗？为什么？

list和dict不可以，但是他们的子类可以。int和tuple不可以，他们的子类也不可以。

8. tuple一个元组，返回的是一个元组的副本
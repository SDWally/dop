# 设计模式-一些不属于经典面向对象设计模式的编程模式

from https://zhuanlan.zhihu.com/p/408521466

## 场景

在实际的软件开发过程中，经常会碰到如下场景：某个模块负责产生数据，这些数据由另一个模块来负责处理（此处的模块是广义的，可以是类、函数、线程、进程等）。产生数据的模块，就形象地称为生产者；而处理数据的模块，就称为消费者。单单抽象出生产者和消费者，还够不上是生产者-消费者模式。该模式还需要有一个缓冲区处于生产者和消费者之间，作为一个中介。生产者把数据放入缓冲区，而消费者从缓冲区取出数据。

## 缓冲区

二、缓冲区
这个缓冲区有什么用？为什么不让生产者直接调用消费者的某个函数，直接把数据传递过去？搞出这么一个缓冲区作甚？其实这里面是大有讲究的，大概有如下一些好处：

- 解耦。如果让生产者直接调用消费者的某个方法，那么生产者对于消费者就会产生依赖（也就是耦合）。将来如果消费者的代码发生变化，可能会影响到生产者。而如果两者都依赖于某个缓冲区，两者之间不直接依赖，耦合也就相应降低了。
- 支持并发。生产者直接调用消费者的某个方法，还有另一个弊端。由于函数调用是同步的（或者叫阻塞的），在消费者的方法没有返回之前，生产者只好一直等在那边。万一消费者处理数据很慢，生产者就会白白糟蹋大好时光。使用了生产者-消费者模式之后，生产者和消费者可以是两个独立的并发主体（常见并发类型有进程和线程两种，后面的帖子会讲两种并发类型下的应用）。生产者把制造出来的数据往缓冲区一丢，就可以再去生产下一个数据。基本上不用依赖消费者的处理速度。
- 支持忙闲不均。缓冲区还有另一个好处。如果制造数据的速度时快时慢，缓冲区的好处就体现出来了。当数据制造快的时候，消费者来不及处理，未处理的数据可以暂时存在缓冲区中。等生产者的制造速度慢下来，消费者再慢慢处理掉。

## 数据单元

数据单元拥有以下特性：

- 完整性。所谓完整性，就是在传输过程中，要保证该数据单元的完整。要么整个数据单元被传递到消费者，要么完全没有传递到消费者。不允许出现部分传递的情形。对于寄信来说，你不能把半封信放入邮筒；同样的，邮递员从邮筒中拿信，也不能只拿出信的一部分。
- 独立性。各个数据单元之间没有互相依赖，某个数据单元传输失败（比如生产者的生产速度在一段时间内一直超过消费者的处理速度，那就会导致缓冲区不断增长并达到上限，之后的数据单元就会被丢弃）不应该影响已经完成传输的单元；也不应该影响尚未传输的单元。

### 缺点

- 可能有频繁的内存分配和释放。如果用队列实现缓冲区，生产者把数据写入队列头（push），消费者从队列尾部读出数据（pop）。对于常见的队列实现，在每次 push 时，可能涉及到堆内存的分配；在每次 pop 时，可能涉及堆内存的释放。假如生产者和消费者都很勤快，频繁地 push、pop，那内存分配的开销就很可观了。解决方案：可以考虑环形缓冲区。
- 同步和互斥的性能消耗。如果用并发线程使用队列，由于两个线程共用一个队列，自然就会涉及到线程间诸如同步啊、互斥啊、死锁啊等等劳心费神的事情，这也是不小的开销。解决方案：稍加优化，用双缓冲区分别给生产者和消费者使用并加锁，在满了 / 空了之后解锁，然后尝试获取对方的缓冲区，这样不用读写每一个数据单元的时候都进行同步 / 互斥操作。
# 线程安全

## 一 

- dict 和 list，tuple这些都是线程安全。
- GIL（全局解释器锁）确保了任何时候只能有一个线程执行相应操作的字节码。
- dict读取数据是线程安全，但是被反复读写就容易出现数据混乱。
- 设计一个线程安全的函数-无状态函数，则可保证线程安全

##　二

- 在Python中，线程安全是针对操作的原子性的，与对象无关
- 操作的原子性
- 原子操作（atomic operation），指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会切换到其他线程，它有点类似数据库中的 事务。

## 常见的原子操作

```
L.append(x) 
L1.extend(L2) 
x = L[i] 
x = L.pop()
L1[i:j] = L2
L.sort()
x = y
x.field = y
D[x] = y
D1.update(D2)
D.keys()
```

## 常见非原子操作

```
i += 1
L.append(L[-1])
L[i] = L[j]
D[x] = D[x] + 1
```

## 原子操作的判断

```
from dis import dis
def func():
    L = []
    L.append(1+1)

dis(func)
```

## 是否线程安全的判断

当一行代码被分成多条字节码指令的时候，就代表在线程线程切换时，有可能只执行了一条字节码指令，此时若这行代码里有被多个线程共享的变量或资源时，并且拆分的多条指令里有对于这个共享变量的写操作，就会发生数据的冲突，导致数据的不准确

## 解决方案

强制同步操作，全局变量非原子操作的地方实行串行同步操作，即，强制原子化，把我们会产生线程安全问题的关键代码加锁，此时锁内的代码即为一个原子操作，再加上GIL锁的影响此时线程是绝对安全的

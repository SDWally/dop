# 迭代器生成器

## 迭代器

- 可迭代对象： 支持迭代，提供方法 obj.__iter__(), 该方法返回一个迭代器对象
- 迭代器对象： 提供方法： iter.__next__() 该方法返回下一个对象 或 StopIteration异常

## 生成器

- 生成器函数： 函数使用特殊的 yield 关键字，就算定义了一个生成器函数。
- 生成器对象： 调用生成器函数，会创建生成器对象。 两个用途：1 迭代器 2 容器

### 主要属性

- g.gi_code 函数代码对象
- g.gi_frame 执行帧
- g.gi_running 显示生成器函数目前是否正在运行的一个整数
- g.__next__ 执行函数，直到遇到下一个yield语句，并返回值
- g.send
- g.close 引发GeneratorExit异常来终止生成器
- g.throw 在生成器的当前yield语句处引发一个异常

## 迭代器与生成器区别

- 迭代器是一个更抽象的概念，任何对象，如果它的类有next方法和iter方法返回自己本身。
- 对于string、list、dict、tuple等这类容器对象，使用for循环遍历是很方便的。
- 在后台for语句对容器对象调用iter()函数，iter()是python的内置函数。iter()会返回一个定义了next()方法的迭代器对象。
- 它在容器中逐个访问容器内元素，next()也是python的内置函数。在没有后续元素时，next()会抛出一个StopIteration异常

- 生成器（Generator）是创建迭代器的简单而强大的工具。
- 它们写起来就像是正规的函数，只是在需要返回数据的时候使用yield语句。
- 每次next()被调用时，生成器会返回它脱离的位置（它记忆语句最后一次执行的位置和所有的数据值）

- 生成器能做到迭代器能做的所有事,
- 而且因为自动创建了__iter__()和next()方法,生成器显得特别简洁,
- 而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。
- 除了创建和保存程序状态的自动方法,当发生器终结时,还会自动抛出StopIteration异常


# Python的内存管理机制

- from https://blog.csdn.net/AudiA6LV6/article/details/126872282
- from http://www.360doc.com/content/22/1125/07/37289152_1057452472.shtml

## 主要部分

- 内存池机制
- 垃圾回收机制

## CPython内存架构图

- python的对象管理主要位于Level+1~Level+3层
Level+3层：对于python内置的对象（比如int,dict等）都有独立的私有内存池，对象之间的内存池不共享，即int释放的内存，不会被分配给float使用
Level+2层：当申请的内存大小小于256KB时，内存分配主要由 Python 对象分配器（Python’s object allocator）实施
Level+1层：当申请的内存大小大于256KB时，由Python原生的内存分配器进行分配，本质上是调用C标准库中的malloc/realloc等函数

- 关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作。

引用计数
Python通过引用计数来保存内存中的变量追踪，即记录该对象被其他使用的对象引用的次数。

Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当某个对象的引用计数为0时，就列入了垃圾回收队列。

>>> a=[1,2]>>> import sys>>> sys.getrefcount(a) ## 获取对象a的引用次数2>>> b=a>>> sys.getrefcount(a)3>>> del b ## 删除b的引用>>> sys.getrefcount(a)2>>> c=list()>>> c.append(a) ## 加入到容器中>>> sys.getrefcount(a)3>>> del c ## 删除容器，引用-1>>> sys.getrefcount(a)2>>> b=a>>> sys.getrefcount(a)3>>> a=[3,4] ## 重新赋值>>> sys.getrefcount(a)2复制代码
注意：当把a作为参数传递给getrefcount时，会产生一个临时的引用，因此得出来的结果比真实情况+1

引用计数增加的情况：
一个对象被分配给一个新的名字（例如：a=[1,2]）
将其放入一个容器中（如列表、元组或字典）（例如：c.append(a)）
引用计数减少的情况：
使用del语句对对象别名显式的销毁(例如：del b)
对象所在的容器被销毁或从容器中删除对象（例如：del c ）
引用超出作用域或被重新赋值（例如：a=[3,4]）
引用计数能够解决大多数垃圾回收的问题，但是遇到两个对象相互引用的情况，del语句可以减少引用次数，但是引用计数不会归0，对象也就不会被销毁，从而造成了内存泄漏问题。针对该情况，Python引入了标记-清除机制。

标记-清除
标记-清除用来解决引用计数机制产生的循环引用，进而导致内存泄漏的问题 。 循环引用只有在容器对象才会产生，比如字典，元组，列表等。

顾名思义，该机制在进行垃圾回收时分成了两步，分别是：

标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达
清除阶段，再次遍历对象，如果发现某个对象没有标记为可达（即为Unreachable），则就将其回收

上面描述的垃圾回收的阶段，会暂停整个应用程序，等待标记清除结束后才会恢复应用程序的运行。为了减少应用程序暂停的时间，Python 通过“分代回收”(Generational Collection)以空间换时间的方法提高垃圾回收效率。

分代回收
分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90%之间。 因此，简单地认为：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度，是一种以空间换时间的方法策略。

Python将所有的对象分为年轻代（第0代）、中年代（第1代）、老年代（第2代）三代。所有的新建对象默认是 第0代对象。当在第0代的gc扫描中存活下来的对象将被移至第1代，在第1代的gc扫描中存活下来的对象将被移至第2代。

gc扫描次数（第0代>第1代>第2代）

当某一代中被分配的对象与被释放的对象之差达到某一阈值时，就会触发当前一代的gc扫描。当某一代被扫描时，比它年轻的一代也会被扫描，因此，第2代的gc扫描发生时，第0，1代的gc扫描也会发生，即为全代扫描。


700=新分配的对象数量-释放的对象数量，第0代gc扫描被触发
第一个10：第0代gc扫描发生10次，则第1代的gc扫描被触发
第二个10：第1代的gc扫描发生10次，则第2代的gc扫描被触发
思考
在标记-清除中，如果对象c也引用a,执行del操作后，会发生什么？

ref_count表示引用计数
对象a,b,c全部为reachable

a,b,c的ref_count减1
执行gc扫描
标记: a引用b,将b的ref_count减1到0，b引用a,将a的ref_count减1到1，将b放在unreachable下
再循环:因为a是可达的，所以会递归地将从a节点出发可以达到的所有节点标记为reachable下，即为：
清除:unreachable下没有可清除的对象，因此a,b,c对象不会被清除
总结
总体而言，python通过内存池来减少内存碎片化，提高执行效率。主要通过引用计数来完成垃圾回收，通过标记-清除解决容器对象循环引用造成的问题，通过分代回收提高垃圾回收的效率。